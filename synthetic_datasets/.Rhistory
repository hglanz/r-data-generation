}
if (is.null(centers)) {
n_centers <- 3
} else if (is.numeric(centers)) {
n_centers <- centers
centers <- matrix(runif(n_centers * n_features, min=center_box[1], max=center_box[2]), nrow=n_centers)
} else {
n_centers <- nrow(centers)
}
samples_per_center <- ceiling(n_samples / n_centers)
cluster_labels <- rep(1:n_centers, each=samples_per_center)[1:n_samples]
X <- matrix(nrow=n_samples, ncol=n_features)
for (i in 1:n_centers) {
center <- if (is.null(centers)) {
runif(n_features, min=center_box[1], max=center_box[2])
} else {
centers[i, ]
}
indices <- which(cluster_labels == i)
X[indices, ] <- mapply(rnorm, n=length(indices), mean=center, sd=cluster_std)
}
if (shuffle) {
indices <- sample(n_samples)
X <- X[indices, ]
cluster_labels <- cluster_labels[indices]
}
if (plot && n_features == 2) {
colors <- rainbow(n_centers)
plot(X, col=colors[cluster_labels], pch=19, main="Generated Blob Clusters")
if (return_centers && !is.null(centers)) {
points(centers, pch=4, col=1:n_centers, lwd=2)
}
} else if (plot) {
warning("Plotting is only available for 2D data.")
}
if (return_centers) {
return(list("X"=X, "y"=cluster_labels, "centers"=centers))
} else {
return(list("X"=X, "y"=cluster_labels))
}
}
# Test Cases
# Test case 1: Default settings
make_blobs(plot=TRUE)
make_blobs(n_samples=200, centers=4, plot=TRUE, random_state=42)
# Test case 3: Custom cluster centers and higher variability
custom_centers <- matrix(c(0, 0, 5, 5, -5, -5), byrow=TRUE, ncol=2)
make_blobs(n_samples=150, centers=custom_centers, cluster_std=2, plot=TRUE, random_state=24)
make_blobs(n_samples=100, n_features=3, centers=3, plot=FALSE, random_state=42)
make_blobs(n_samples=100, n_features=3, centers=3, plot=TRUE, random_state=42)
make_blobs <- function(n_samples=100, n_features=2, centers=NULL, cluster_std=1.0,
center_box=c(-10, 10), shuffle=TRUE, random_state=NULL, return_centers=FALSE, plot=FALSE) {
if (!is.null(random_state)) {
set.seed(random_state)
}
if (is.null(centers)) {
n_centers <- 3
centers <- matrix(runif(n_centers * n_features, min=center_box[1], max=center_box[2]), nrow=n_centers, ncol=n_features)
} else if (is.numeric(centers)) {
n_centers <- centers
centers <- matrix(runif(n_centers * n_features, min=center_box[1], max=center_box[2]), nrow=n_centers, ncol=n_features)
} else {
n_centers <- nrow(centers)
if (ncol(centers) != n_features) {
stop("centers must have the same number of columns as n_features")
}
}
samples_per_center <- ceiling(n_samples / n_centers)
cluster_labels <- rep(1:n_centers, each=samples_per_center)[1:n_samples]
X <- matrix(NA, nrow=n_samples, ncol=n_features)
for (i in 1:n_centers) {
center <- centers[i, ]
indices <- which(cluster_labels == i)
for (j in 1:n_features) {
X[indices, j] <- rnorm(length(indices), mean=center[j], sd=cluster_std)
}
}
if (shuffle) {
indices <- sample(n_samples)
X <- X[indices, ]
cluster_labels <- cluster_labels[indices]
}
if (plot && n_features == 2) {
colors <- rainbow(n_centers)
plot(X, col=colors[cluster_labels], pch=19, xlab="Feature 1", ylab="Feature 2", main="Generated Blob Clusters")
if (return_centers) {
points(centers, pch=4, col=1:n_centers, lwd=2)
}
} else if (plot) {
warning("Plotting is only available for 2D data.")
}
if (return_centers) {
return(list("X"=X, "y"=cluster_labels, "centers"=centers))
} else {
return(list("X"=X, "y"=cluster_labels))
}
}
# Test case 3: Custom cluster centers and higher variability
custom_centers <- matrix(c(0, 0, 5, 5, -5, -5), byrow=TRUE, ncol=2)
make_blobs(n_samples=150, centers=custom_centers, cluster_std=2, plot=TRUE, random_state=24)
make_blobs <- function(n_samples=100, n_features=2, centers=NULL, cluster_std=1.0,
center_box=c(-10, 10), shuffle=TRUE, random_state=NULL, return_centers=FALSE, plot=FALSE) {
if (!is.null(random_state)) {
set.seed(random_state)
}
if (is.null(centers)) {
n_centers <- 3
} else if (is.numeric(centers)) {
n_centers <- centers
centers <- matrix(runif(n_centers * n_features, min=center_box[1], max=center_box[2]), nrow=n_centers)
} else {
n_centers <- nrow(centers)
}
samples_per_center <- ceiling(n_samples / n_centers)
cluster_labels <- rep(1:n_centers, each=samples_per_center)[1:n_samples]
X <- matrix(nrow=n_samples, ncol=n_features)
for (i in 1:n_centers) {
center <- if (is.null(centers)) {
runif(n_features, min=center_box[1], max=center_box[2])
} else {
centers[i, ]
}
indices <- which(cluster_labels == i)
X[indices, ] <- mapply(rnorm, n=length(indices), mean=center, sd=cluster_std)
}
if (shuffle) {
indices <- sample(n_samples)
X <- X[indices, ]
cluster_labels <- cluster_labels[indices]
}
if (plot && n_features == 2) {
colors <- rainbow(n_centers)
plot(X, col=colors[cluster_labels], pch=19, main="Generated Blob Clusters")
if (return_centers && !is.null(centers)) {
points(centers, pch=4, col=1:n_centers, lwd=2)
}
} else if (plot) {
warning("Plotting is only available for 2D data.")
}
if (return_centers) {
return(list("X"=X, "y"=cluster_labels, "centers"=centers))
} else {
return(list("X"=X, "y"=cluster_labels))
}
}
# Test Cases
# Test case 1: Default settings
make_blobs(plot=TRUE)
make_blobs <- function(n_samples=100, n_features=2, centers=NULL, cluster_std=1.0,
center_box=c(-10, 10), shuffle=TRUE, random_state=NULL, return_centers=FALSE, plot=FALSE) {
if (!is.null(random_state)) {
set.seed(random_state)
}
if (is.null(centers)) {
n_centers <- 3
} else if (is.numeric(centers)) {
n_centers <- centers
centers <- matrix(runif(n_centers * n_features, min=center_box[1], max=center_box[2]), nrow=n_centers)
} else {
n_centers <- nrow(centers)
}
samples_per_center <- ceiling(n_samples / n_centers)
cluster_labels <- rep(1:n_centers, each=samples_per_center)[1:n_samples]
X <- matrix(nrow=n_samples, ncol=n_features)
for (i in 1:n_centers) {
center <- if (is.null(centers)) {
runif(n_features, min=center_box[1], max=center_box[2])
} else {
centers[i, ]
}
indices <- which(cluster_labels == i)
X[indices, ] <- mapply(rnorm, n=length(indices), mean=center, sd=cluster_std)
}
if (shuffle) {
indices <- sample(n_samples)
X <- X[indices, ]
cluster_labels <- cluster_labels[indices]
}
if (plot && n_features == 2) {
colors <- rainbow(n_centers)
plot(X, col=colors[cluster_labels], pch=19, main="Generated Blob Clusters")
if (return_centers && !is.null(centers)) {
points(centers, pch=4, col=1:n_centers, lwd=2)
}
} else if (plot) {
warning("Plotting is only available for 2D data.")
}
if (return_centers) {
return(list("X"=X, "y"=cluster_labels, "centers"=centers))
} else {
return(list("X"=X, "y"=cluster_labels))
}
}
# Test Cases
# Test case 1: Default settings
make_blobs(plot=TRUE)
make_blobs <- function(n_samples=100, n_features=2, centers=NULL, cluster_std=1.0,
center_box=c(-10, 10), shuffle=TRUE, random_state=NULL, return_centers=FALSE, plot=FALSE) {
if (!is.null(random_state)) {
set.seed(random_state)
}
if (is.null(centers)) {
n_centers <- 3
} else if (is.numeric(centers)) {
n_centers <- centers
centers <- matrix(runif(n_centers * n_features, min=center_box[1], max=center_box[2]), nrow=n_centers)
} else {
n_centers <- nrow(centers)
}
samples_per_center <- ceiling(n_samples / n_centers)
cluster_labels <- rep(1:n_centers, each=samples_per_center)[1:n_samples]
X <- matrix(nrow=n_samples, ncol=n_features)
for (i in 1:n_centers) {
center <- if (is.null(centers)) {
runif(n_features, min=center_box[1], max=center_box[2])
} else {
centers[i, ]
}
indices <- which(cluster_labels == i)
X[indices, ] <- mapply(rnorm, n=length(indices), mean=center, sd=cluster_std)
}
if (shuffle) {
indices <- sample(n_samples)
X <- X[indices, ]
cluster_labels <- cluster_labels[indices]
}
if (plot && n_features == 2) {
colors <- rainbow(n_centers)
plot(X, col=colors[cluster_labels], pch=19, main="Generated Blob Clusters")
if (return_centers && !is.null(centers)) {
points(centers, pch=4, col=1:n_centers, lwd=2)
}
} else if (plot) {
warning("Plotting is only available for 2D data.")
}
if (return_centers) {
return(list("X"=X, "y"=cluster_labels, "centers"=centers))
} else {
return(list("X"=X, "y"=cluster_labels))
}
}
# Test Cases
# Test case 1: Default settings
make_blobs(plot=TRUE)
make_blobs <- function(n_samples=100, n_features=2, centers=NULL, cluster_std=1.0,
center_box=c(-10, 10), shuffle=TRUE, random_state=NULL, return_centers=FALSE, plot=FALSE) {
if (!is.null(random_state)) {
set.seed(random_state)
}
if (is.null(centers)) {
n_centers <- 3
} else if (is.numeric(centers)) {
n_centers <- centers
centers <- matrix(runif(n_centers * n_features, min=center_box[1], max=center_box[2]), nrow=n_centers)
} else {
n_centers <- nrow(centers)
}
samples_per_center <- ceiling(n_samples / n_centers)
cluster_labels <- rep(1:n_centers, each=samples_per_center)[1:n_samples]
X <- matrix(nrow=n_samples, ncol=n_features)
for (i in 1:n_centers) {
center <- if (is.null(centers)) {
runif(n_features, min=center_box[1], max=center_box[2])
} else {
centers[i, ]
}
indices <- which(cluster_labels == i)
X[indices, ] <- mapply(rnorm, n=length(indices), mean=center, sd=cluster_std)
}
if (shuffle) {
indices <- sample(n_samples)
X <- X[indices, ]
cluster_labels <- cluster_labels[indices]
}
if (plot && n_features == 2) {
colors <- rainbow(n_centers)
plot(X, col=colors[cluster_labels], pch=19, main="Generated Blob Clusters")
if (return_centers && !is.null(centers)) {
points(centers, pch=4, col=1:n_centers, lwd=2)
}
} else if (plot) {
warning("Plotting is only available for 2D data.")
}
if (return_centers) {
return(list("X"=X, "y"=cluster_labels, "centers"=centers))
} else {
return(list("X"=X, "y"=cluster_labels))
}
}
# Test Cases
# Test case 1: Default settings
make_blobs(plot=TRUE)
make_blobs <- function(n_samples=100, n_features=2, centers=NULL, cluster_std=1.0,
center_box=c(-10, 10), shuffle=TRUE, random_state=NULL, return_centers=FALSE, plot=FALSE) {
if (!is.null(random_state)) {
set.seed(random_state)
}
if (is.null(centers)) {
n_centers <- 3
} else if (is.numeric(centers)) {
n_centers <- centers
centers <- matrix(runif(n_centers * n_features, min=center_box[1], max=center_box[2]), nrow=n_centers)
} else {
n_centers <- nrow(centers)
}
samples_per_center <- ceiling(n_samples / n_centers)
cluster_labels <- rep(1:n_centers, each=samples_per_center)[1:n_samples]
X <- matrix(nrow=n_samples, ncol=n_features)
for (i in 1:n_centers) {
center <- if (is.null(centers)) {
runif(n_features, min=center_box[1], max=center_box[2])
} else {
centers[i, ]
}
indices <- which(cluster_labels == i)
X[indices, ] <- mapply(rnorm, n=length(indices), mean=center, sd=cluster_std)
}
if (shuffle) {
indices <- sample(n_samples)
X <- X[indices, ]
cluster_labels <- cluster_labels[indices]
}
if (plot && n_features == 2) {
colors <- rainbow(n_centers)
plot(X, col=colors[cluster_labels], pch=19, main="Generated Blob Clusters")
if (return_centers && !is.null(centers)) {
points(centers, pch=4, col=1:n_centers, lwd=2)
}
} else if (plot) {
warning("Plotting is only available for 2D data.")
}
if (return_centers) {
return(list("X"=X, "y"=cluster_labels, "centers"=centers))
} else {
return(list("X"=X, "y"=cluster_labels))
}
}
# Test Cases
# Test case 1: Default settings
make_blobs(plot=TRUE)
make_blobs <- function(n_samples=100, n_features=2, centers=NULL, cluster_std=1.0,
center_box=c(-10, 10), shuffle=TRUE, random_state=NULL, return_centers=FALSE, plot=FALSE) {
if (!is.null(random_state)) {
set.seed(random_state)
}
if (is.null(centers)) {
n_centers <- 3
} else if (is.numeric(centers)) {
n_centers <- centers
centers <- matrix(runif(n_centers * n_features, min=center_box[1], max=center_box[2]), nrow=n_centers)
} else {
n_centers <- nrow(centers)
}
samples_per_center <- ceiling(n_samples / n_centers)
cluster_labels <- rep(1:n_centers, each=samples_per_center)[1:n_samples]
X <- matrix(nrow=n_samples, ncol=n_features)
for (i in 1:n_centers) {
center <- if (is.null(centers)) {
runif(n_features, min=center_box[1], max=center_box[2])
} else {
centers[i, ]
}
indices <- which(cluster_labels == i)
X[indices, ] <- mapply(rnorm, n=length(indices), mean=center, sd=cluster_std)
}
if (shuffle) {
indices <- sample(n_samples)
X <- X[indices, ]
cluster_labels <- cluster_labels[indices]
}
if (plot && n_features == 2) {
colors <- rainbow(n_centers)
plot(X, col=colors[cluster_labels], pch=19, main="Generated Blob Clusters")
if (return_centers && !is.null(centers)) {
points(centers, pch=4, col=1:n_centers, lwd=2)
}
} else if (plot) {
warning("Plotting is only available for 2D data.")
}
if (return_centers) {
return(list("X"=X, "y"=cluster_labels, "centers"=centers))
} else {
return(list("X"=X, "y"=cluster_labels))
}
}
# Test Cases
# Test case 1: Default settings
make_blobs(plot=TRUE)
make_blobs(n_samples=200, centers=4, plot=TRUE, random_state=42)
make_blobs(n_samples=200, centers=4, plot=TRUE, random_state=42)
make_blobs(n_samples=200, centers=4, plot=TRUE, random_state=42)
make_blobs(n_samples=200, centers=4, plot=TRUE, random_state=42)
make_blobs(n_samples=200, centers=4, plot=TRUE)
make_blobs(n_samples=200, centers=4, plot=TRUE)
make_blobs(n_samples=200, centers=4, plot=TRUE)
make_blobs(n_samples=200, centers=4, plot=TRUE)
make_blobs(n_samples=200, centers=4, plot=TRUE)
make_blobs(n_samples=200, centers=4, plot=TRUE)
make_blobs(n_samples=100, n_features=3, centers=3, plot=TRUE, random_state=42)
library(scatterplot3d)
library(scatterplot3d)
make_blobs <- function(n_samples=100, n_features=2, centers=NULL, cluster_std=1.0,
center_box=c(-10, 10), shuffle=TRUE, random_state=NULL, return_centers=FALSE, plot=FALSE) {
if (!is.null(random_state)) {
set.seed(random_state)
}
if (is.null(centers)) {
n_centers <- 3
} else if (is.numeric(centers)) {
n_centers <- centers
centers <- matrix(runif(n_centers * n_features, min=center_box[1], max=center_box[2]), nrow=n_centers)
} else {
n_centers <- nrow(centers)
}
samples_per_center <- ceiling(n_samples / n_centers)
cluster_labels <- rep(1:n_centers, each=samples_per_center)[1:n_samples]
X <- matrix(nrow=n_samples, ncol=n_features)
for (i in 1:n_centers) {
center <- if (is.null(centers)) {
runif(n_features, min=center_box[1], max=center_box[2])
} else {
centers[i, ]
}
indices <- which(cluster_labels == i)
X[indices, ] <- mapply(rnorm, n=length(indices), mean=center, sd=cluster_std)
}
if (shuffle) {
indices <- sample(n_samples)
X <- X[indices, ]
cluster_labels <- cluster_labels[indices]
}
if (plot) {
if (n_features == 2) {
colors <- rainbow(n_centers)
plot(X, col=colors[cluster_labels], pch=19, xlab="Feature 1", ylab="Feature 2", main="Generated Blob Clusters")
if (return_centers) {
points(centers, pch=4, col=1:n_centers, lwd=2)
}
} else if (n_features == 3) {
colors <- rainbow(n_centers)
scatterplot3d(X[,1], X[,2], X[,3], color=colors[cluster_labels], pch=19, xlab="Feature 1", ylab="Feature 2", zlab="Feature 3", main="Generated Blob Clusters")
if (return_centers) {
scatterplot3d(centers[,1], centers[,2], centers[,3], color=1:n_centers, pch=4, lwd=2, add=TRUE)
}
} else {
warning("Plotting is available only for 2D and 3D data.")
}
}
if (return_centers) {
return(list("X"=X, "y"=cluster_labels, "centers"=centers))
} else {
return(list("X"=X, "y"=cluster_labels))
}
}
# Test Cases
# Test case 1: Default settings
make_blobs(plot=TRUE)
# Test case 2: Increased number of samples and 4 clusters
make_blobs(n_samples=200, centers=4, plot=TRUE)
# Test case 3: Custom cluster centers and higher variability
custom_centers <- matrix(c(0, 0, 5, 5, -5, -5), byrow=TRUE, ncol=2)
make_blobs(n_samples=150, centers=custom_centers, cluster_std=2, plot=TRUE, random_state=24)
make_blobs(n_samples=100, n_features=3, centers=3, plot=TRUE, random_state=42)
make_blobs(n_samples=100, n_features=3, centers=3, plot=TRUE)
make_blobs(n_samples=100, n_features=3, centers=3, plot=TRUE)
make_blobs(n_samples=100, n_features=3, centers=3, plot=TRUE)
make_blobs(n_samples=100, n_features=3, centers=3, plot=TRUE)
make_blobs(n_samples=100, n_features=3, centers=3, plot=TRUE)
make_moons <- function(n_samples = 100, shuffle = TRUE, noise = NULL, random_state = NULL, plot = FALSE) {
if (!is.null(random_state)) {
set.seed(random_state)
}
# Generate moon data
x1 <- seq(-pi, 0, length.out = n_samples / 2)
x2 <- seq(0, pi, length.out = n_samples / 2)
# First moon
y1 <- cbind(1 - cos(x1), sin(x1))
# Second moon
y2 <- cbind(1 - cos(x2) + 0.5, sin(x2) - 1)
data <- rbind(y1, y2)
# Add noise if specified
if (!is.null(noise)) {
data <- data + matrix(rnorm(n_samples * 2, sd = noise), ncol = 2)
}
# Shuffle data if specified
if (shuffle) {
data <- data[sample(n_samples), ]
}
# Labels for the moons
labels <- c(rep(1, n_samples / 2), rep(2, n_samples / 2))
if (shuffle) {
labels <- labels[sample(n_samples)]
}
# Plot if specified
if (plot) {
plot(data, col = labels, xlab = "Feature 1", ylab = "Feature 2", main = "Generated Moon Clusters", pch = 19)
legend("topright", legend = c("Moon 1", "Moon 2"), col = 1:2, pch = 19)
}
return(list("X" = data, "y" = labels))
}
# Basic moon generation without noise
make_moons(n_samples = 200, plot = TRUE)
make_moons(n_samples = 200, plot = TRUE, shuffle = FALSE)
make_moons(n_samples = 200, noise = 0.1, plot = TRUE, shuffle = FALSE)
make_moons(n_samples = 200, noise = 0.1, random_state = 42, plot = TRUE)
make_moons(n_samples = 200, noise = 0.8, random_state = 42, plot = TRUE)
make_moons(n_samples = 200, noise = 0.4, random_state = 42, plot = TRUE)
make_moons(n_samples = 200, noise = 0.3, random_state = 42, plot = TRUE)
make_moons(n_samples = 200, noise = 0.23, random_state = 42, plot = TRUE)
make_moons(n_samples = 500, plot = TRUE, shuffle = FALSE)
make_moons(n_samples = 20, plot = TRUE, shuffle = FALSE)
make_moons(n_samples = 500, plot = TRUE, shuffle = FALSE)
