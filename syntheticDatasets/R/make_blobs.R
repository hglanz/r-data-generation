library(scatterplot3d)
okabe_ito_colors <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442",
                      "#0072B2", "#D55E00", "#CC79A7", "#999999")
#' Generate Blob Dataset
#'
#' This function generates a "blobs" dataset, useful for testing clustering algorithms. The blobs are isotropic Gaussian blobs for clustering, and the user can specify the number of centers (blobs), the standard deviation of the blobs, and the number of features for each sample. The function can return the blob centers if desired and supports plotting for 2D and 3D data.
#'
#' @param n_samples Total number of samples to generate. Default is 100.
#' @param n_features Number of features for each sample. Default is 2.
#' @param centers Number of centers to generate, or the specific coordinates of the centers. If `NULL`, 3 centers are generated by default. Can be an integer or a matrix of center coordinates.
#' @param cluster_std Standard deviation of the clusters. Default is 1.0.
#' @param center_box A vector of length 2 indicating the bounds for the center coordinates. Default is c(-10, 10).
#' @param shuffle Logical, indicating whether to shuffle the samples. Default is TRUE.
#' @param random_state Integer, the seed used by the random number generator for reproducibility. Can be `NULL`. Default is `NULL`.
#' @param return_centers Logical, indicating whether to return the centers of the blobs. Default is FALSE.
#' @param plot Logical, indicating whether to plot the dataset. Plotting is supported for 2D and 3D data only. Default is FALSE.
#' @return A list containing at least two elements: 'X' is a matrix with the coordinates of each sample, 'y' is a vector indicating the blob (center) each sample belongs to, and 'centers' are the coordinates of the blob centers if `return_centers` is TRUE.
#' @examples
#' # Generate and plot a default blobs dataset
#' blobs_data <- make_blobs(plot = TRUE)
#'
#' # Generate blobs with specific centers and plot
#' centers <- matrix(c(0,0, 5,5, 10,10), ncol=2, byrow=TRUE)
#' custom_blobs <- make_blobs(n_samples=300, centers=centers, plot=TRUE)
#' @export
make_blobs <- function(n_samples=100, n_features=2, centers=NULL, cluster_std=1.0,
                       center_box=c(-10, 10), shuffle=TRUE, random_state=NULL, return_centers=FALSE, plot=FALSE) {
  if (!is.null(random_state)) {
    set.seed(random_state)
  }

  if (is.null(centers)) {
    n_centers <- 3
    centers <- matrix(runif(n_centers * n_features, min=center_box[1], max=center_box[2]), nrow=n_centers)
  } else if (is.numeric(centers) && length(centers) == 1) {
    n_centers <- centers
    centers <- matrix(runif(n_centers * n_features, min=center_box[1], max=center_box[2]), nrow=n_centers)
  } else {
    n_centers <- nrow(centers)
  }

  samples_per_center <- ceiling(n_samples / n_centers)
  cluster_labels <- rep(1:n_centers, each=samples_per_center)[1:n_samples]

  X <- matrix(nrow=n_samples, ncol=n_features)
  for (i in 1:n_centers) {
    center <- centers[i, ]
    indices <- which(cluster_labels == i)
    X[indices, ] <- mapply(rnorm, n=length(indices), mean=center, sd=cluster_std)
  }

  if (shuffle) {
    indices <- sample(n_samples)
    X <- X[indices, ]
    cluster_labels <- cluster_labels[indices]
  }

  if (plot) {
    if (n_features == 2) {
      colors <- okabe_ito_colors[1:n_centers]
      plot(X, col=colors[cluster_labels], pch=19, xlab="Feature 1", ylab="Feature 2", main="Generated Blob Clusters")
      legend("topright", legend = paste("Blob", 1:n_centers), fill = colors)
      if (return_centers) {
        points(centers, pch=4, col=1:n_centers, lwd=2)
      }
    } else if (n_features == 3) {
      colors <- okabe_ito_colors[1:n_centers]
      scatterplot3d(X[,1], X[,2], X[,3], color=colors[cluster_labels], pch=19, xlab="Feature 1", ylab="Feature 2", zlab="Feature 3", main="Generated Blob Clusters")
      if (return_centers) {
        scatterplot3d(centers[,1], centers[,2], centers[,3], color=1:n_centers, pch=4, lwd=2, add=TRUE)
      }
    } else {
      warning("Plotting is available only for 2D and 3D data.")
    }
  }

  if (return_centers) {
    return(list("X"=X, "y"=cluster_labels, "centers"=centers))
  } else {
    return(list("X"=X, "y"=cluster_labels))
  }
}
